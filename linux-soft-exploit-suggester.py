#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Linux Soft Exploit Suggester
# Search Exploitable Software
# belane 2017

import re
import os
import argparse
import csv
import platform

badpackages = ('centos','debian','ubuntu','redhat','addon','agent','apps','base','cache','check','client',
            'command','common','configuration','control','core','data','database','dev','editor','events',
            'extras','family','file','files','form','generic','headers','info','installation','kernel',
            'legacy','linux','load','manager','message','module','monitor','net','network','one','open',
            'plugin','plugins','release','router','server','software','standard','support','system','team',
            'text','the','theme','time','tools','update','user','utility','viewer','web','wifi','wireless')

def loadVulns(file):
    """ Load vulns from csv file to vulns_list """
    file_vulns = open(file, 'rb')
    reader = csv.reader(file_vulns)
    vulns_list = list(reader)
    file_vulns.close()
    return vulns_list

def parseDebian(file):
    """ Parse debian packages list to dict (name:version) """
    result = {}
    for line in file:
        if args.clean==True: c = 0
        else: c = 1
        if args.clean==True or line[:2] == 'ii':
            l = line.split()
            # Software name
            n = l[c].find(':')
            if n != -1:
                so = l[c][:n]
            else:
                so = l[c]
            # Version
            n = re.search(r"-|\+|~",l[c+1])
            if n:
                v = l[c+1][:n.span()[0]]
            else:
                v = l[c+1]
            n = v.find(':')
            if n != -1:
                v = v[n+1:]
            # Intense software name split
            if args.intense and '-' in so:
                s = so.split('-')
                for p in s:
                    if len(p)>2 and '.' not in p and p not in badpackages: result[p]=v
            else:
                result[so]=v
    return result

def parseRedhat(file):
    """ Parse redhat packages list to dict (name:version) """
    result = {}
    for line in file:
        l = '.'.join(line.split('.')[:-2])
        l = l.split('-')
        # Software name
        so = '-'.join(l[:-2])
        # Version
        v = l[-2]
        # Intense software name split
        if args.intense and '-' in so:
            s = so.split('-')
            for p in s:
                if len(p)>2 and '.' not in p and p not in badpackages: result[p.lower()]=v
        else:
            result[so.lower()]=v
    return result

def versionVar(v):
    """ Return Version variations from selected level """
    if args.level == 1: r = v       # Same version
    elif args.level == 2:           # Eliminate micro and patch versions
        if '.' in v: r = '.'.join(v.split('.')[:-1])
        else: r = v[:4]
        if len(r) == 1: r = v[:3]
    elif args.level == 3: r = v[:3] # Minor version
    elif args.level == 4: r = v[0]  # Major version
    elif args.level == 5: r = ''    # Whitout version
    return r

def searchExploit(vulns_list,s,v):
    """ Search affected packages in vulns_list """
    for vuln in vulns_list:
        if args.filter == None or args.filter.lower() in vuln[2].lower():       # Filter
            if args.type == None or args.type == vuln[5] + ':' + vuln[6]:       # Type
                if vuln[5]!='windows' and (args.dos or vuln[6]!='dos'):         # DoS and Windows
                    n = re.search('(^|\s)' + s.replace('+', '\+') + '(\s|\s.*\s|\s.*\/)' + versionVar(v) + '.* -', vuln[2],re.IGNORECASE)
                    if n:
                        if args.duplicates == False: vulns_list.remove(vuln)    # Duplicates
                        print '[+]\033[0;32m', vuln[2],'\033[0m' + vuln[5] + ':' + vuln[6]
                        print '\t', 'From:', s, v, '\033[0;90m(' + s+':'+versionVar(v)+')\033[0m'
                        print '\t', 'File: /usr/share/exploitdb/' + vuln[1]
                        print '\t', 'Url: https://www.exploit-db.com/exploits/' + vuln[0]


if __name__ == "__main__":
    # Banner
    print('\033[95m' + """
    LINUX SOFTWARE EXPLOIT SUGESTER  v0.4
    """ + '\033[0m')
    # Args
    parser = argparse.ArgumentParser(description='Search for Exploitable Software')
    parser.add_argument('-f', '--file', type=str, required=True,  help='packages file list')
    parser.add_argument('--clean',  action='store_true', help='use clean packages list')
    parser.add_argument('--duplicates', action='store_true', help='show duplicates vulns')
    parser.add_argument('--db', type=str,  help='vulnerabilities csv file')
    parser.add_argument('-d', '--distribution', metavar='debian|redhat', type=str, choices=set(('debian','redhat')), default='debian', help='linux flavor, debian or redhat (default: debian)')
    parser.add_argument('--dos', action='store_true', help='include DoS exploits')
    parser.add_argument('--intense', action='store_true', help='include intense search (experimental)')
    parser.add_argument('-l', '--level', metavar='1-5', type=int, choices=set((1,2,3,4,5)), default=1, help='software version variation (default: 1)')
    parser.add_argument('--type', type=str, metavar="system:scope", help='type of vuln, recommended linux:local')
    parser.add_argument('--filter', type=str,  help='filter vulns by string')
    args = parser.parse_args()

    if not os.path.isfile(args.file):
        print "File not found!"
        exit()

    # Default: file from running path, on Kali linux from system file
    vulns_db='files.csv'
    if platform.dist()[0] == 'Kali': vulns_db='/usr/share/exploitdb/files.csv'
    if args.db: vulns_db=args.db
    if not os.path.isfile(vulns_db):
        print "Vuln DB not found!"
        exit()

    # Linux flavor packages list load
    file_packages = open(args.file,'r')
    if args.distribution == 'redhat':
        soft = parseRedhat(file_packages)
    else:
        soft = parseDebian(file_packages)
    file_packages.close()
    # Vulns list load
    vulns_list = loadVulns(vulns_db)
    for s, v in soft.items():
        searchExploit(vulns_list,s,v)
