#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Linux Soft Exploit Suggester
# Search Exploitable Software
# belane 2017

import re
import os
import argparse
import csv
import platform

badpackages = ('centos','debian','ubuntu','redhat','addon','agent','apps','base','cache','check','client',
            'command','common','configuration','control','core','data','database','dev','editor','events',
            'extras','family','file','files','form','generic','headers','info','installation','kernel',
            'legacy','linux','load','manager','message','module','monitor','net','network','one','open',
            'plugin','plugins','release','router','server','software','standard','support','system','team',
            'text','the','theme','time','tools','update','user','utility','viewer','web','wifi','wireless')

def loadVulns(vulns_file):
    """ Load vulns from csv file to vulns_list """
    file_vulns = open(vulns_file, 'rb')
    reader = csv.reader(file_vulns)
    vulns_list = list(reader)
    file_vulns.close()
    return vulns_list

def parseDebian(packages_file):
    """ Parse debian package list to dict (name:version) """
    result = {}
    if args.clean==True: first_field = 0
    else: first_field = 1
    for line in packages_file:
        if args.clean==True or line[:2] == 'ii':
            fields = line.split()
            # Software name
            search = fields[first_field].find(':')
            if search != -1:
                soft_name = fields[first_field][:search]
            else:
                soft_name = fields[first_field]
            # Version
            search = re.search(r"-|\+|~",fields[first_field + 1])
            if search:
                soft_version = fields[first_field + 1][:search.span()[0]]
            else:
                soft_version = fields[first_field + 1]
            search = soft_version.find(':')
            if search != -1:
                soft_version = soft_version[search + 1:]
            # Intense package name split
            if args.intense and '-' in soft_name:
                for sub_package in soft_name.split('-'):
                    if len(sub_package)>2 and '.' not in sub_package and sub_package not in badpackages: result[sub_package] = soft_version
            else:
                result[soft_name] = soft_version
    return result

def parseRedhat(packages_file):
    """ Parse redhat package list to dict (name:version) """
    result = {}
    for line in packages_file:
        fields = '.'.join(line.split('.')[:-2]).split('-')
        # Software name
        soft_name = '-'.join(fields[:-2])
        # Version
        soft_version = fields[-2]
        # Intense package name split
        if args.intense and '-' in soft_name:
            for sub_package in soft_name.split('-'):
                if len(sub_package)>2 and '.' not in sub_package and sub_package not in badpackages: result[sub_package.lower()] = soft_version
        else:
            result[soft_name.lower()] = soft_version
    return result

def versionVar(soft_version):
    """ Return Version variations from selected level """
    if args.level == 1: return soft_version         # Same version
    elif args.level == 2:                           # Eliminate micro and patch versions
        if '.' in soft_version: result = '.'.join(soft_version.split('.')[:-1])
        else: result = soft_version[:4]
        if len(result) == 1: result = soft_version[:3]
    elif args.level == 3: return soft_version[:3]   # Minor version
    elif args.level == 4: return soft_version[0]    # Major version
    elif args.level == 5: return ''                 # Whitout version
    return result

def searchExploit(vulns_list, soft_name, soft_version):
    """ Search affected packages in vulns_list """
    result = []
    for vuln in vulns_list:
        if vuln[5]!='windows' and (args.dos or vuln[6]!='dos'):                 # DoS and Windows
            if args.filter == None or args.filter.lower() in vuln[2].lower():   # Filter
                if args.type == None or args.type in (vuln[5] + ':' + vuln[6]): # Type
                    if re.search('(^|\s)' + soft_name.replace('+', '\+') + '(\s|\s.*\s|\s.*\/)' + versionVar(soft_version) + '.* -', vuln[2],re.IGNORECASE):
                        if args.duplicates == False: vulns_list.remove(vuln)    # Duplicates
                        printOutput(vuln, soft_name, soft_version)
                        result.append([vuln, soft_name, soft_version])
    return result

def printOutput(vuln_details, soft_name, soft_version):
    """ Print formated output """
    print '[+]\033[0;32m', vuln_details[2],'\033[0m' + vuln_details[5] + ':' + vuln_details[6]
    print '\t', 'From:', soft_name, soft_version, '\033[0;90m(' + soft_name+':'+versionVar(soft_version)+')\033[0m'
    print '\t', 'File: /usr/share/exploitdb/' + vuln_details[1]
    print '\t', 'Url: https://www.exploit-db.com/exploits/' + vuln_details[0]

def updateDB():
    """ Download latest Vuln DB """
    update_url = 'https://raw.githubusercontent.com/offensive-security/exploit-database/master/files.csv'
    try:
        print 'Updating vulnerabilities db:',
        import urllib
        urllib.urlretrieve(update_url, 'files.csv')
        print 'DONE.'
    except:
        print 'ERROR. Unable to download.'


if __name__ == "__main__":
    # Banner
    print('\033[95m\033[1m' + """
  |  _         __ _  _ |    _    _ | _  |    __    __  __  _  __ |   _  _
  |·| || |\/  (_ | ||_ |-  /_)\/| \|| |·|-  (_ | ||  )|  )/_)(_  |- /_)|
  ||| ||_|/\  __)|_||  |_  \_ /\|_/||_|||_  __)|_||_/ |_/ \_ __) |_ \_ |
                                |                 _/  _/
    """ + '\033[0m')
    # Help & Args
    usage_examples = 'usage examples: \
    \n  Update database:\n\tpython linux-soft-exploit-suggester.py --update \
    \n  Basic usage:\n\tpython linux-soft-exploit-suggester.py --file package_list \
    \n  Specify vuln db:\n\tpython linux-soft-exploit-suggester.py --file package_list --db file.cve \
    \n  Redhat/Centos format file:\n\tpython linux-soft-exploit-suggester.py --file package_list --distribution redhat \
    \n  Search major version vulnerabilities:\n\tpython linux-soft-exploit-suggester.py --file package_list --level 4 \
    \n  Filter by remote type exploits:\n\tpython linux-soft-exploit-suggester.py --file package_list --type :remote \
    \n  Search specific words in exploit title:\n\tpython linux-soft-exploit-suggester.py --file package_list --filter Overflow \
    \n  Advanced usage:\n\tpython linux-soft-exploit-suggester.py --file package_list --level 3 --type linux:local --filter escalation '
    parser = argparse.ArgumentParser(description='linux-soft-exploit-suggester:\n  Search for Exploitable Software from package list.',
                                    formatter_class=argparse.RawTextHelpFormatter,
                                    add_help=False, epilog=usage_examples)
    parser.add_argument('-h', '--help', action='help', default=argparse.SUPPRESS, help='Show this help message and exit')
    parser.add_argument('-f', '--file', type=str, help='Package file list')
    parser.add_argument('--clean',  action='store_true', help='Use clean package list')
    parser.add_argument('--duplicates', action='store_true', help='Show duplicates vulns')
    parser.add_argument('--db', type=str,  help='Vulnerabilities csv file [default: file.csv]')
    parser.add_argument('--update', action='store_true',  help='Download latest version of vulnerabilities db')
    parser.add_argument('-d', '--distribution', metavar='debian|redhat', type=str, choices=set(('debian','redhat')), default='debian', help='Linux flavor, debian or redhat [default: debian]')
    parser.add_argument('--dos', action='store_true', help='Include DoS exploits')
    parser.add_argument('--intense', action='store_true', help='Include intense package name search (experimental)')
    parser.add_argument('-l', '--level', metavar='1-5', type=int, choices=set((1,2,3,4,5)), default=1, help='Software version variation [default: 1]\
                        \n  level 1: Same version\
                        \n  level 2: Eliminate micro and patch versions\
                        \n  level 3: Minor version\
                        \n  level 4: Major version\
                        \n  level 5: Whitout version')
    parser.add_argument('--type', type=str, metavar="system:scope", help='Type of vuln, recommended linux:local\n  e.g.\t--type linux:\n\t--type :local\n\t--type multi:remote')
    parser.add_argument('--filter', type=str,  help='Filter vulns by string\n  e.g.\t--filter "escalation"')
    args = parser.parse_args()

    # Required parameters
    if not (args.file or args.update):
        print 'missing parameter: argument -f/--file or --update is required\n'
        parser.print_help()
        exit()

    # Update DB
    if args.update:
        updateDB()
        exit()

    if not os.path.isfile(args.file):
        print 'File not found!'
        exit()

    # Default: DB from running path, on Kali linux from system DB
    vulns_db='files.csv'
    if platform.dist()[0] == 'Kali': vulns_db='/usr/share/exploitdb/files.csv'
    if args.db: vulns_db = args.db
    if not os.path.isfile(vulns_db):
        print 'Vuln DB not found!'
        print 'Use \'--update\' to download latest version'
        exit()

    # Linux flavor package list load
    packages_file = open(args.file,'r')
    if args.distribution == 'redhat':
        soft_list = parseRedhat(packages_file)
    else:
        soft_list = parseDebian(packages_file)
    packages_file.close()
    # Vulns list load
    vulns_list = loadVulns(vulns_db)
    # Search Exploits
    for soft_name, soft_version in soft_list.items():
        searchExploit(vulns_list, soft_name, soft_version)

    # TODO: Export Results / Reporting
