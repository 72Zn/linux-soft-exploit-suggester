#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Linux Soft Exploit Suggester
# Search Exploitable Software
# belane 2017

import re
import os
import argparse
import csv
import platform

badpackages = ('centos','debian','ubuntu','redhat','addon','agent','apps','base','cache','check','client',
            'command','common','configuration','control','core','data','database','dev','editor','events',
            'extras','family','file','files','form','generic','headers','info','installation','kernel',
            'legacy','linux','load','manager','message','module','monitor','net','network','one','open',
            'plugin','plugins','release','router','server','software','standard','support','system','team',
            'text','the','theme','time','tools','update','user','utility','viewer','web','wifi','wireless')

def loadVulns(vulns_file):
    """ Load vulns from csv file to vulns_list """
    file_vulns = open(vulns_file, 'rb')
    reader = csv.reader(file_vulns)
    vulns_list = list(reader)
    file_vulns.close()
    return vulns_list

def parseDebian(packages_file):
    """ Parse debian packages list to dict (name:version) """
    result = {}
    if args.clean==True: first_field = 0
    else: first_field = 1
    for line in packages_file:
        if args.clean==True or line[:2] == 'ii':
            fields = line.split()
            # Software name
            search = fields[first_field].find(':')
            if search != -1:
                soft_name = fields[first_field][:search]
            else:
                soft_name = fields[first_field]
            # Version
            search = re.search(r"-|\+|~",fields[first_field + 1])
            if search:
                soft_version = fields[first_field + 1][:search.span()[0]]
            else:
                soft_version = fields[first_field + 1]
            search = soft_version.find(':')
            if search != -1:
                soft_version = soft_version[search + 1:]
            # Intense package name split
            if args.intense and '-' in soft_name:
                for sub_package in soft_name.split('-'):
                    if len(sub_package)>2 and '.' not in sub_package and sub_package not in badpackages: result[sub_package] = soft_version
            else:
                result[soft_name] = soft_version
    return result

def parseRedhat(packages_file):
    """ Parse redhat packages list to dict (name:version) """
    result = {}
    for line in packages_file:
        fields = '.'.join(line.split('.')[:-2]).split('-')
        # Software name
        soft_name = '-'.join(fields[:-2])
        # Version
        soft_version = fields[-2]
        # Intense package name split
        if args.intense and '-' in soft_name:
            for sub_package in soft_name.split('-'):
                if len(sub_package)>2 and '.' not in sub_package and sub_package not in badpackages: result[sub_package.lower()] = soft_version
        else:
            result[soft_name.lower()] = soft_version
    return result

def versionVar(soft_version):
    """ Return Version variations from selected level """
    if args.level == 1: return soft_version         # Same version
    elif args.level == 2:                           # Eliminate micro and patch versions
        if '.' in soft_version: result = '.'.join(soft_version.split('.')[:-1])
        else: result = soft_version[:4]
        if len(result) == 1: result = soft_version[:3]
    elif args.level == 3: return soft_version[:3]   # Minor version
    elif args.level == 4: return soft_version[0]    # Major version
    elif args.level == 5: return ''                 # Whitout version
    return result

def searchExploit(vulns_list, soft_name, soft_version):
    """ Search affected packages in vulns_list """
    for vuln in vulns_list:
        if vuln[5]!='windows' and (args.dos or vuln[6]!='dos'):                 # DoS and Windows
            if args.filter == None or args.filter.lower() in vuln[2].lower():   # Filter
                if args.type == None or args.type == vuln[5] + ':' + vuln[6]:   # Type
                    if re.search('(^|\s)' + soft_name.replace('+', '\+') + '(\s|\s.*\s|\s.*\/)' + versionVar(soft_version) + '.* -', vuln[2],re.IGNORECASE):
                        if args.duplicates == False: vulns_list.remove(vuln)    # Duplicates
                        printOutput(vuln, soft_name, soft_version)
    # TODO: return

def printOutput(vuln_details, soft_name, soft_version):
    """ Print formated output """
    print '[+]\033[0;32m', vuln_details[2],'\033[0m' + vuln_details[5] + ':' + vuln_details[6]
    print '\t', 'From:', soft_name, soft_version, '\033[0;90m(' + soft_name+':'+versionVar(soft_version)+')\033[0m'
    print '\t', 'File: /usr/share/exploitdb/' + vuln_details[1]
    print '\t', 'Url: https://www.exploit-db.com/exploits/' + vuln_details[0]

def updateDB():
    """ Download latest Vuln DB """
    try:
        print 'Updating vulnerabilities db:',
        import urllib
        urllib.urlretrieve('https://raw.githubusercontent.com/offensive-security/exploit-database/master/files.csv', 'files.csv')
        print 'DONE.'
    except:
        print 'ERROR. Unable to download.'


if __name__ == "__main__":
    # Banner
    print('\033[95m' + """
    LINUX SOFTWARE EXPLOIT SUGESTER  v0.5
    """ + '\033[0m')
    # Args
    parser = argparse.ArgumentParser(description='Search for Exploitable Software')
    parser.add_argument('-f', '--file', type=str, help='packages file list')
    parser.add_argument('--clean',  action='store_true', help='use clean packages list')
    parser.add_argument('--duplicates', action='store_true', help='show duplicates vulns')
    parser.add_argument('--db', type=str,  help='vulnerabilities csv file')
    parser.add_argument('--update', action='store_true',  help='download latest version of vulnerabilities db')
    parser.add_argument('-d', '--distribution', metavar='debian|redhat', type=str, choices=set(('debian','redhat')), default='debian', help='linux flavor, debian or redhat (default: debian)')
    parser.add_argument('--dos', action='store_true', help='include DoS exploits')
    parser.add_argument('--intense', action='store_true', help='include intense package name search (experimental)')
    parser.add_argument('-l', '--level', metavar='1-5', type=int, choices=set((1,2,3,4,5)), default=1, help='software version variation (default: 1)')
    parser.add_argument('--type', type=str, metavar="system:scope", help='type of vuln, recommended linux:local')
    parser.add_argument('--filter', type=str,  help='filter vulns by string')
    args = parser.parse_args()

    # Required parameters
    if not (args.file or args.update):
        print 'missing parameter: argument -f/--file or --update is required'
        exit()

    # Update DB
    if args.update:
        updateDB()
        exit()

    if not os.path.isfile(args.file):
        print 'File not found!'
        exit()

    # Default: DB from running path, on Kali linux from system DB
    vulns_db='files.csv'
    if platform.dist()[0] == 'Kali': vulns_db='/usr/share/exploitdb/files.csv'
    if args.db: vulns_db = args.db
    if not os.path.isfile(vulns_db):
        print 'Vuln DB not found!'
        print 'Use \'--update\' to download latest version'
        exit()

    # Linux flavor packages list load
    packages_file = open(args.file,'r')
    if args.distribution == 'redhat':
        soft_list = parseRedhat(packages_file)
    else:
        soft_list = parseDebian(packages_file)
    packages_file.close()
    # Vulns list load
    vulns_list = loadVulns(vulns_db)
    # Search Exploits
    for soft_name, soft_version in soft_list.items():
        searchExploit(vulns_list, soft_name, soft_version)

    # TODO: Export Results / Reporting
